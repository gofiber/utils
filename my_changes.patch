diff --git a/time.go b/time.go
index ddd8856..7be7bd8 100644
--- a/time.go
+++ b/time.go
@@ -7,47 +7,52 @@ import (
 )
 
 var (
-	timestampTimer sync.Once
-	timestamp      uint32
-	stopChan       chan struct{}
+	timestamp   uint32
+	updaterOnce sync.Once
+	stopUpdater chan struct{}
+	updaterDone chan struct{}
 )
 
-// Timestamp returns the current time.
-// Make sure to start the updater once using StartTimeStampUpdater() before calling.
+// Timestamp returns the current cached Unix timestamp (seconds).
+// Call StartTimeStampUpdater() once at app startup for best performance.
 func Timestamp() uint32 {
 	return atomic.LoadUint32(&timestamp)
 }
 
-// StartTimeStampUpdater starts a concurrent function which stores the timestamp to an atomic value per second,
-// which is much better for performance than determining it at runtime each time
+// StartTimeStampUpdater launches a background goroutine that updates the cached timestamp every second.
+// It is safe to call multiple times; only the first call will start the updater.
 func StartTimeStampUpdater() {
-	timestampTimer.Do(func() {
+	updaterOnce.Do(func() {
 		atomic.StoreUint32(&timestamp, uint32(time.Now().Unix()))
+		stopUpdater = make(chan struct{})
+		updaterDone = make(chan struct{})
 
-		c := make(chan struct{})
-		stopChan = c
-
-		go func(localChan chan struct{}, sleep time.Duration) {
-			ticker := time.NewTicker(sleep)
+		go func() {
+			ticker := time.NewTicker(time.Second)
 			defer ticker.Stop()
+			defer close(updaterDone)
 
 			for {
 				select {
-				case t := <-ticker.C:
-					atomic.StoreUint32(&timestamp, uint32(t.Unix()))
-				case <-localChan:
+				case <-ticker.C:
+					atomic.StoreUint32(&timestamp, uint32(time.Now().Unix()))
+				case <-stopUpdater:
 					return
 				}
 			}
-		}(c, 1*time.Second)
+		}()
 	})
 }
 
-// StopTimeStampUpdater stops the timestamp updater
-// WARNING: Make sure to call this function before the program exits, otherwise it will leak goroutines
+// StopTimeStampUpdater stops the background updater goroutine.
+// Call this on app shutdown to avoid leaking goroutines.
 func StopTimeStampUpdater() {
-	if stopChan != nil {
-		close(stopChan)
-		stopChan = nil
+	if stopUpdater != nil {
+		close(stopUpdater)
+		<-updaterDone
+		// Reset the sync.Once so StartTimeStampUpdater can be called again
+		updaterOnce = sync.Once{}
+		stopUpdater = nil
+		updaterDone = nil
 	}
 }
diff --git a/time_test.go b/time_test.go
index ca74ffa..533004e 100644
--- a/time_test.go
+++ b/time_test.go
@@ -1,52 +1,79 @@
 package utils
 
 import (
+	"sync"
 	"testing"
 	"time"
 
 	"github.com/stretchr/testify/require"
 )
 
+var timerTestMu sync.Mutex
+
 func checkTimeStamp(tb testing.TB, expectedCurrent, actualCurrent uint32) {
 	tb.Helper()
-	// test with some buffer in front and back of the expectedCurrent time -> because of the timing on the work machine
-	require.True(tb, true, actualCurrent >= expectedCurrent-1 || actualCurrent <= expectedCurrent+1)
+	// Test with buffer of ±2 seconds for CI environment tolerance
+	require.True(tb, actualCurrent >= expectedCurrent-2 && actualCurrent <= expectedCurrent+2,
+		"Expected timestamp %d (±2s), got %d (diff: %d)", expectedCurrent, actualCurrent, int64(actualCurrent)-int64(expectedCurrent))
 }
 
 func Test_TimeStampUpdater(t *testing.T) {
+	timerTestMu.Lock()
+	defer timerTestMu.Unlock()
+
 	StartTimeStampUpdater()
+	defer StopTimeStampUpdater()
 
 	now := uint32(time.Now().Unix())
-	checkTimeStamp(t, now, Timestamp())
 
-	// one second later
-	time.Sleep(1 * time.Second)
-	checkTimeStamp(t, now+1, Timestamp())
+	// Give it a moment to initialize
+	time.Sleep(100 * time.Millisecond)
+
+	ts := Timestamp()
+	require.True(t, ts >= now-1 && ts <= now+1,
+		"Initial timestamp should be within ±1 second of current time. Expected: %d±1, got: %d (diff: %d)",
+		now, ts, int64(ts)-int64(now))
 
-	// two seconds later
-	time.Sleep(1 * time.Second)
-	checkTimeStamp(t, now+2, Timestamp())
+	// Wait for next update
+	time.Sleep(1100 * time.Millisecond)
+
+	ts2 := Timestamp()
+	require.Greater(t, ts2, ts,
+		"Timestamp should have updated after 1+ seconds. Initial: %d, after 1s: %d",
+		ts, ts2)
+
+	currentTime := uint32(time.Now().Unix())
+	require.True(t, ts2 >= now && ts2 <= currentTime+1,
+		"Updated timestamp should be between test start (%d) and current time (%d), got: %d",
+		now, currentTime, ts2)
 }
 
 func Test_StopTimeStampUpdater(t *testing.T) {
-	// Start the timestamp updater
+	timerTestMu.Lock()
+	defer timerTestMu.Unlock()
+
 	StartTimeStampUpdater()
 
-	// Stop the updater
-	StopTimeStampUpdater()
+	// Get initial timestamp
+	time.Sleep(100 * time.Millisecond)
+	initial := Timestamp()
 
-	// Capture the timestamp after stopping
-	stoppedTime := Timestamp()
+	StopTimeStampUpdater()
 
-	// Wait before checking the timestamp
-	time.Sleep(5 * time.Second)
-	// It should not have changed since we've stopped the updater
-	require.Equal(t, stoppedTime, Timestamp(), "timestamp should not change after stopping updater")
+	// Verify it stops updating
+	time.Sleep(2 * time.Second)
+	final := Timestamp()
+	currentTime := uint32(time.Now().Unix())
+	require.Equal(t, initial, final,
+		"Timestamp should not change after stopping updater. Stopped at: %d, checked at: %d (wall time: %d)",
+		initial, final, currentTime)
 }
 
 func Benchmark_CalculateTimestamp(b *testing.B) {
-	var res uint32
+	timerTestMu.Lock()
+	defer timerTestMu.Unlock()
 	StartTimeStampUpdater()
+	defer StopTimeStampUpdater()
 
 	b.Run("fiber", func(bb *testing.B) {
 		bb.ReportAllocs()
@@ -55,6 +82,7 @@ func Benchmark_CalculateTimestamp(b *testing.B) {
 			_ = Timestamp()
 		}
 	})
+
 	b.Run("default", func(bb *testing.B) {
 		bb.ReportAllocs()
 		bb.ResetTimer()
@@ -67,16 +95,24 @@ func Benchmark_CalculateTimestamp(b *testing.B) {
 		bb.ReportAllocs()
 		bb.ResetTimer()
 		for n := 0; n < bb.N; n++ {
-			res = Timestamp()
+			res := Timestamp()
+			bb.StopTimer()
 			checkTimeStamp(bb, uint32(time.Now().Unix()), res)
+			bb.StartTimer()
 		}
 	})
+
 	b.Run("default_asserted", func(bb *testing.B) {
 		bb.ReportAllocs()
 		bb.ResetTimer()
 		for n := 0; n < bb.N; n++ {
-			res = uint32(time.Now().Unix())
-			checkTimeStamp(bb, uint32(time.Now().Unix()), res)
+			bb.StopTimer()
+			expected := uint32(time.Now().Unix())
+			bb.StartTimer()
+			res := uint32(time.Now().Unix())
+			bb.StopTimer()
+			checkTimeStamp(bb, expected, res)
+			bb.StartTimer()
 		}
 	})
 }
